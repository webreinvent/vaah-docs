---
toc: true
title: Local Storage
description: Documentation on using local storage options (Hive and Flutter Secure Storage) with Vaah Flutter.
---

## Overview

Vaah Flutter provides two local storage options: Hive and Flutter Secure Storage. This section guides you through setting up and using these local storage solutions.

Select one option from Hive and Flutter Secure Storage.

| Hive  | Flutter Secure Storage |
| :---- |          :----         |
| The `LocalStorageWithHive` class implements the `LocalStorageService` interface using Hive as the storage backend. It is used when `LocalStorageType.hive` is selected in the configuration. | The `LocalStorageWithFlutterSecureStorage` class implements the `LocalStorageService` interface using Flutter Secure Storage as the storage backend. It is used when `LocalStorageType.flutterSecureStorage` is selected in the configuration. |

## Setup

### If you select Hive

Configure the storage type in the env.dart file.

```dart
final EnvironmentConfig defaultConfig = EnvironmentConfig(
  // other configurations
  localStorageType: LocalStorageType.hive,
);
```

### If you select Flutter Secure Storage

Configure the storage type in the env.dart file.

```dart
final EnvironmentConfig defaultConfig = EnvironmentConfig(
  // other configurations
  localStorageType: LocalStorageType.flutterSecureStorage,
);
```

::alert{type="info" class="flex items-center p-4 mb-4 text-sm text-blue-800 rounded-lg bg-blue-50 dark:bg-gray-800 dark:text-blue-400" role="alert"}
For more information about environment configuration [click here](../../../../3.essentials/2.environments.md).
::

## Usage Guide

### **Create Items**

```dart
await LocalStorage.create(key: 'key34', value: '34'); // single
await LocalStorage.createMany(values: {
  'key2': 'Value2',
  'key3': 'Value3',
}); // multiple
```

### **Read Items**

```dart
final value = await LocalStorage.read(key: 'key34'); // single
final values = await LocalStorage.readMany(keys: ['key2', 'key3']); // multiple
final values = await LocalStorage.readAll(); // all
```

### **Update Items**
```dart
await LocalStorage.update(); //single
await LocalStorage.updateMany(); // multiple
```

### **Create or Update Items**
```dart
await LocalStorage.createOrUpdate(); // single
await LocalStorage.createOrUpdateMany(); // multiple
```

### **Delete Items**

```dart
await LocalStorage.delete(key: 'key34'); // single
await LocalStorage.deleteAll(keys: ['key2', 'key3']); // multiple
await LocalStorage.deleteAll(); // all
```

## Best Practices
### With `toJson` and `fromJson` Methods
To store and retrieve complex objects, use toJson and fromJson methods for serialization and deserialization.

### Example
1. Define Data Model
``` dart
class User {
  String id;
  String name;
  String email;

  User({
    required this.id,
    required this.name,
    required this.email,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'email': email,
    };
  }

  factory User.fromMap(Map<String, dynamic> map) {
    return User(
      id: map['id'] as String,
      name: map['name'] as String,
      email: map['email'] as String,
    );
  }

  String toJson() => json.encode(toMap());
  factory User.fromJson(String source) => User.fromMap(json.decode(source));
}
```

2. Store a User Object
```dart
final User user = User(id: '1', name: 'John Doe', email: 'john.doe@example.com');
await LocalStorage.create(key: 'user_1', value: user.toJson());
```

3. Retrieve a User Object
```dart
final String? userJson = await LocalStorage.read(key: 'user_1');
if (userJson != null) {
  final User user = User.fromJson(userJson);
}
```

## Source Code

### LocalStorageService Class (Base Class)

```dart 
abstract class LocalStorageService {
  void add(String collectionName);

  Future<void> create({String collectionName, required String key, required String value});

  Future<void> createMany({String collectionName, required Map<String, String> values});

  Future<String?> read({String collectionName, required String key});

  Future<Map<String, String?>> readMany({String collectionName, required List<String> keys});

  Future<Map<String, String?>> readAll({String collectionName});

  Future<void> update({String collectionName, required String key, required String value});

  Future<void> updateMany({String collectionName, required Map<String, String> values});

  Future<void> createOrUpdate({String collectionName, required String key, required String value});

  Future<void> createOrUpdateMany({String collectionName, required Map<String, String> values});

  Future<void> delete({String collectionName, required String key});

  Future<void> deleteMany({String collectionName, List<String> keys = const []});

  Future<void> deleteAll({String collectionName});
}
```


### LocalStorageWihtHive Class
This class implements the LocalStorageSerivce interface using Hive as the storage backend.

```dart
import 'package:hive/hive.dart';

import 'base_service.dart';

/// A class implementing LocalStorageService interface using Hive as storage backend.
class LocalStorageWithHive implements LocalStorageService {
  final Map<String, Future<Box>> _collections = {
    'vaah-flutter-box': Hive.openBox('vaah-flutter-box'),
  };

  @override
  void add(String collectionName) {
    assert(!_collections.containsKey(collectionName), 'The Box "$collectionName" already exists');

    _collections[collectionName] = Hive.openBox(collectionName);
  }

  @override
  Future<void> create({
    String collectionName = 'vaah-flutter-box',
    required String key,
    required String value,
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    assert(!box.containsKey(key), 'The key "$key" already exists.');

    await box.put(key, value);
  }

  @override
  Future<void> createMany(
      {String collectionName = 'vaah-flutter-box', required Map<String, String> values}) async {
    for (String k in values.keys) {
      await create(collectionName: collectionName, key: k, value: values[k]!);
    }
  }

  @override
  Future<String?> read({String collectionName = 'vaah-flutter-box', required String key}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    String? result = box.get(key);
    return result;
  }

  @override
  Future<Map<String, String?>> readMany({
    String collectionName = 'vaah-flutter-box',
    required List<String> keys,
  }) async {
    if (keys.isNotEmpty) {
      Map<String, String?> result = {};
      for (String k in keys) {
        result[k] = await read(collectionName: collectionName, key: k);
      }
      return result;
    } else {
      return {};
    }
  }

  @override
  Future<Map<String, String?>> readAll({String collectionName = 'vaah-flutter-box'}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    Map<String, String?> result = box.toMap().map(
          (key, value) => MapEntry(
            key.toString(),
            value?.toString(),
          ),
        );
    return result;
  }

  @override
  Future<void> update({
    String collectionName = 'vaah-flutter-box',
    required String key,
    required String value,
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    assert(box.containsKey(key), 'The key "$key" does not exist.');

    box.put(key, value);
  }

  @override
  Future<void> updateMany({
    String collectionName = 'vaah-flutter-box',
    required Map<String, String> values,
  }) async {
    for (String k in values.keys) {
      await update(collectionName: collectionName, key: k, value: values[k]!);
    }
  }

  @override
  Future<void> createOrUpdate({
    String collectionName = 'vaah-flutter-box',
    required String key,
    required String value,
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    box.put(key, value);
  }

  @override
  Future<void> createOrUpdateMany({
    String collectionName = 'vaah-flutter-box',
    required Map<String, String> values,
  }) async {
    for (String k in values.keys) {
      await createOrUpdate(collectionName: collectionName, key: k, value: values[k]!);
    }
  }

  @override
  Future<void> delete({String collectionName = 'vaah-flutter-box', dynamic key}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    await box.delete(key);
  }

  @override
  Future<void> deleteMany({
    String collectionName = 'vaah-flutter-box',
    List<String> keys = const [],
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    if (keys.isNotEmpty) {
      await box.deleteAll(keys);
    }
  }

  @override
  Future<void> deleteAll({String collectionName = 'vaah-flutter-box'}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    await box.clear();
  }
}
```

### LocalStorageWithFlutterSecureStorage Class

This class implements the LocalStorageService interface using Flutter Secure Storage as the storage backend.

```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'base_service.dart';

/// A class implementing LocalStorageService interface using FLutter Secure Storage as storage
/// backend.
class LocalStorageWithFlutterSecureStorage implements LocalStorageService {
  final _storage = const FlutterSecureStorage();

  @override
  void add(String name) {}

  @override
  Future<void> create({
    String collectionName = '',
    required String key,
    required String value,
  }) async {
    assert(!(await _storage.containsKey(key: key)), 'The key "$key" already exists.');

    await _storage.write(key: key, value: value);
  }

  @override
  Future<void> createMany({String collectionName = '', required Map<String, String> values}) async {
    for (String k in values.keys) {
      await create(key: k, value: values[k]!);
    }
  }

  @override
  Future<String?> read({String collectionName = '', required String key}) async {
    String? result = await _storage.read(key: key);
    return result;
  }

  @override
  Future<Map<String, String?>> readMany({
    String collectionName = '',
    required List<String> keys,
  }) async {
    if (keys.isNotEmpty) {
      Map<String, String?> result = {};
      for (String k in keys) {
        result[k] = await _storage.read(key: k);
      }
      return result;
    } else {
      return {};
    }
  }

  @override
  Future<Map<String, String?>> readAll({String collectionName = ''}) async {
    final Map<String, String> result = await _storage.readAll();
    return result;
  }

  @override
  Future<void> update({
    String collectionName = '',
    required String key,
    required String value,
  }) async {
    assert(await _storage.containsKey(key: key), 'The key "$key" does not exists.');

    await _storage.write(key: key, value: value);
  }

  @override
  Future<void> updateMany({String collectionName = '', required Map<String, String> values}) async {
    for (String k in values.keys) {
      await update(key: k, value: values[k]!);
    }
  }

  @override
  Future<void> createOrUpdate({
    String collectionName = '',
    required String key,
    required String value,
  }) async {
    await _storage.write(key: key, value: value);
  }

  @override
  Future<void> createOrUpdateMany({
    String collectionName = '',
    required Map<String, String> values,
  }) async {
    for (String k in values.keys) {
      await createOrUpdate(key: k, value: values[k]!);
    }
  }

  @override
  Future<void> delete({String collectionName = '', required String key}) async {
    await _storage.delete(key: key);
  }

  @override
  Future<void> deleteMany({String collectionName = '', List<String> keys = const []}) async {
    if (keys.isNotEmpty) {
      for (String k in keys) {
        await _storage.delete(key: k);
      }
    }
  }

  @override
  Future<void> deleteAll({String collectionName = ''}) async {
    await _storage.deleteAll();
  }
}
```