---
toc: true
title: Local Storage
description: Documentation on using local storage options (Hive and Flutter Secure Storage) with Vaah Flutter.
---

## Overview

Vaah Flutter provides two local storage options: Hive and Flutter Secure Storage. This section guides you through setting up and using these local storage solutions.

Select one option from Hive and Flutter Secure Storage.

| Hive  | Flutter Secure Storage |
| :---- |          :----         |
| The `LocalStorageWithHive` class implements the `LocalStorageService` interface using Hive as the storage backend. It is used when `LocalStorageType.hive` is selected in the configuration. | The `LocalStorageWithFlutterSecureStorage` class implements the `LocalStorageService` interface using Flutter Secure Storage as the storage backend. It is used when `LocalStorageType.flutterSecureStorage` is selected in the configuration. |

## Setup

### If you select Hive

1. Configure the local storage type by providing the type in the valid JSON env files: develop.json, staging.json, production.json, or any custom file you have created for env configuration.

```json
{
  "other_json_fields": "Other Json values",

  "local_storage_type": "hive",
}
```

2. Add a Box if you want to use a collection other than the default 'vaah-flutter-box'.

```dart
  LocalStorage.add('my-user-box');
```
::alert{type="danger" class="flex items-center p-4 mb-4 text-sm text-red-800 border border-red-300 rounded-lg bg-red-50 dark:bg-gray-800 dark:text-red-400 dark:border-red-800" role="alert"}
The `LocalStorage.add` method must be called before using the other methods.
::

::alert{type="info" class="flex flex-col p-4 mb-4 text-m text-blue-800 rounded-lg bg-blue-50 dark:bg-gray-800 dark:text-blue-400" role="alert"}
If you want to perform operations (i.e., CRUD) in other collections the `collectionName` will be required every time as shown in the example :
```dart 
await LocalStorage.create(collectionName: 'my-user-box', key: 'user1', value: 'user object1');

final value = await LocalStorage.read(collectionName: 'my-user-box', key: 'user1');
```
::


### If you select Flutter Secure Storage

Configure the local storage type by specifying it in the valid JSON env files: develop.json, staging.json, production.json, or any custom file you have created for env configuration.

```json
{
  "other_json_fields": "Other Json values",

  "local_storage_type": "flutterSecureStorage",
}
```

:::alert{type="info" class="flex flex-col p-4 mb-4 text-m text-blue-800 rounded-lg bg-blue-50 dark:bg-gray-800 dark:text-blue-400" role="alert"}
If you want to perform operations (i.e., CRUD) you don't have to pass the `collectionName` as shown in the example:
```dart
await LocalStorage.create(key: 'user1', value: 'user object1');

final value = await LocalStorage.read(key: 'user1');
```

:::


::alert{type="info" class="flex items-center p-4 mb-4 text-sm text-blue-800 rounded-lg bg-blue-50 dark:bg-gray-800 dark:text-blue-400" role="alert"}
For more information about environment configuration [click here](../../../../3.essentials/2.environments.md).
::

## Usage Guide

After setting up the Local Storage, you can use the following methods to perform CRUD operations.

### **Create Items**

```dart
await LocalStorage.create(collectionName: 'my-user-box', key: 'key34', value: '98'); // single

await LocalStorage.createMany(
      collectionName: 'my-user-box',
      values: {
        'key2': 'Value2',
        'key3': 'Value3',
        'key4': 'Value4',
        'key5': 'Value5',
      },
    ); // multiple
```

### **Read Items**

```dart
final value =  await LocalStorage.read(collectionName: 'my-user-box', key: 'key34'); // single

final values = await LocalStorage.readMany(
  collectionName: 'my-user-box',
  keys: ['key3', 'key2', 'key4', 'key5'],
); // multiple

final values = await LocalStorage.readAll(collectionName: 'my-user-box'); // all
```

### **Update Items**
```dart
await LocalStorage.update(collectionName: 'my-user-box', key: 'key34', value: '1000'); //single

await LocalStorage.updateMany(
  collectionName: 'my-user-box',
  values: {
    'key2': 'UpdatedValue2',
    'key3': 'UpdatedValue3',
    'key4': 'UpdatedValue4',
    'key5': 'UpdatedValue5',
  },
); // multiple
```

### **Create or Update Items**
```dart
await LocalStorage.createOrUpdate(collectionName: 'my-user-box', key: 'key34', value: '1000'); // single

await LocalStorage.createOrUpdateMany(
  collectionName: 'my-user-box',
  values: {
    'key2': 'Value2',
    'key3': 'Value3',
    'key4': 'Value4',
    'key5': 'Value5',
  },
); // multiple
```

### **Delete Items**

```dart
await LocalStorage.delete(collectionName: 'my-user-box', key: 'key34'); // single

await LocalStorage.deleteMany(
  collectionName: 'my-user-box',
  keys: ['key3', 'key2', 'key4', 'key5'],
); // multiple

await LocalStorage.deleteAll(); // all
```

::alert{type="info" class="flex flex-col items-center p-4 mb-4 text-sm text-blue-800 rounded-lg bg-blue-50 dark:bg-gray-800 dark:text-blue-400" role="alert"}
No need to provide `coillectionName` when using Flutter Secure Storage or Hive with the default collection.
::

## Best Practices

### With `toJson` and `fromJson` Methods
To store and retrieve complex objects, use `toJson` and `fromJson` methods for serialization and deserialization.

### Example
1. Define Data Model
``` dart
class User {
  String id;
  String name;
  String email;

  User({
    required this.id,
    required this.name,
    required this.email,
  });

  Map<String, dynamic> toMap() {
    return {
      'id': id,
      'name': name,
      'email': email,
    };
  }

  factory User.fromMap(Map<String, dynamic> map) {
    return User(
      id: map['id'] as String,
      name: map['name'] as String,
      email: map['email'] as String,
    );
  }

  String toJson() => json.encode(toMap());
  factory User.fromJson(String source) => User.fromMap(json.decode(source));
}
```

2. Store a User Object
```dart
final User user = User(id: '1', name: 'John Doe', email: 'john.doe@example.com');
await LocalStorage.create(key: 'user_1', value: user.toJson());
```

3. Retrieve a User Object
```dart
final String? userJson = await LocalStorage.read(key: 'user_1');
if (userJson != null) {
  final User user = User.fromJson(userJson);
}
```

## Source Code

### LocalStorageService Class (Base Class)

```dart 
abstract class LocalStorageService {
  void add(String collectionName);

  Future<void> create({String collectionName, required String key, required String value});

  Future<void> createMany({String collectionName, required Map<String, String> values});

  Future<String?> read({String collectionName, required String key});

  Future<Map<String, String?>> readMany({String collectionName, required List<String> keys});

  Future<Map<String, String?>> readAll({String collectionName});

  Future<void> update({String collectionName, required String key, required String value});

  Future<void> updateMany({String collectionName, required Map<String, String> values});

  Future<void> createOrUpdate({String collectionName, required String key, required String value});

  Future<void> createOrUpdateMany({String collectionName, required Map<String, String> values});

  Future<void> delete({String collectionName, required String key});

  Future<void> deleteMany({String collectionName, List<String> keys = const []});

  Future<void> deleteAll({String collectionName});
}
```


### LocalStorageWithHive Class
This class implements the LocalStorageSerivce interface using Hive as the storage backend.

```dart
import 'package:hive/hive.dart';

import 'base_service.dart';

/// A class implementing LocalStorageService interface using Hive as storage backend.
class LocalStorageWithHive implements LocalStorageService {
  final Map<String, Future<Box>> _collections = {
    'vaah-flutter-box': Hive.openBox('vaah-flutter-box'),
  };

  @override
  void add(String collectionName) {
    assert(!_collections.containsKey(collectionName), 'The Box "$collectionName" already exists');

    _collections[collectionName] = Hive.openBox(collectionName);
  }

  @override
  Future<void> create({
    String collectionName = 'vaah-flutter-box',
    required String key,
    required String value,
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    assert(!box.containsKey(key), 'The key "$key" already exists.');

    await box.put(key, value);
  }

  @override
  Future<void> createMany(
      {String collectionName = 'vaah-flutter-box', required Map<String, String> values}) async {
    for (String k in values.keys) {
      await create(collectionName: collectionName, key: k, value: values[k]!);
    }
  }

  @override
  Future<String?> read({String collectionName = 'vaah-flutter-box', required String key}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    String? result = box.get(key);
    return result;
  }

  @override
  Future<Map<String, String?>> readMany({
    String collectionName = 'vaah-flutter-box',
    required List<String> keys,
  }) async {
    if (keys.isNotEmpty) {
      Map<String, String?> result = {};
      for (String k in keys) {
        result[k] = await read(collectionName: collectionName, key: k);
      }
      return result;
    } else {
      return {};
    }
  }

  @override
  Future<Map<String, String?>> readAll({String collectionName = 'vaah-flutter-box'}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    Map<String, String?> result = box.toMap().map(
          (key, value) => MapEntry(
            key.toString(),
            value?.toString(),
          ),
        );
    return result;
  }

  @override
  Future<void> update({
    String collectionName = 'vaah-flutter-box',
    required String key,
    required String value,
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    assert(box.containsKey(key), 'The key "$key" does not exist.');

    box.put(key, value);
  }

  @override
  Future<void> updateMany({
    String collectionName = 'vaah-flutter-box',
    required Map<String, String> values,
  }) async {
    for (String k in values.keys) {
      await update(collectionName: collectionName, key: k, value: values[k]!);
    }
  }

  @override
  Future<void> createOrUpdate({
    String collectionName = 'vaah-flutter-box',
    required String key,
    required String value,
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    box.put(key, value);
  }

  @override
  Future<void> createOrUpdateMany({
    String collectionName = 'vaah-flutter-box',
    required Map<String, String> values,
  }) async {
    for (String k in values.keys) {
      await createOrUpdate(collectionName: collectionName, key: k, value: values[k]!);
    }
  }

  @override
  Future<void> delete({String collectionName = 'vaah-flutter-box', dynamic key}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    await box.delete(key);
  }

  @override
  Future<void> deleteMany({
    String collectionName = 'vaah-flutter-box',
    List<String> keys = const [],
  }) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    if (keys.isNotEmpty) {
      await box.deleteAll(keys);
    }
  }

  @override
  Future<void> deleteAll({String collectionName = 'vaah-flutter-box'}) async {
    assert(_collections.containsKey(collectionName), 'The Box "$collectionName" does not exists.');

    Box box = await _collections[collectionName]!;
    await box.clear();
  }
}
```

### LocalStorageWithFlutterSecureStorage Class

This class implements the LocalStorageService interface using Flutter Secure Storage as the storage backend.

```dart
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import 'base_service.dart';

/// A class implementing LocalStorageService interface using FLutter Secure Storage as storage
/// backend.
class LocalStorageWithFlutterSecureStorage implements LocalStorageService {
  final _storage = const FlutterSecureStorage();

  @override
  void add(String name) {}

  @override
  Future<void> create({
    String collectionName = '',
    required String key,
    required String value,
  }) async {
    assert(!(await _storage.containsKey(key: key)), 'The key "$key" already exists.');

    await _storage.write(key: key, value: value);
  }

  @override
  Future<void> createMany({String collectionName = '', required Map<String, String> values}) async {
    for (String k in values.keys) {
      await create(key: k, value: values[k]!);
    }
  }

  @override
  Future<String?> read({String collectionName = '', required String key}) async {
    String? result = await _storage.read(key: key);
    return result;
  }

  @override
  Future<Map<String, String?>> readMany({
    String collectionName = '',
    required List<String> keys,
  }) async {
    if (keys.isNotEmpty) {
      Map<String, String?> result = {};
      for (String k in keys) {
        result[k] = await _storage.read(key: k);
      }
      return result;
    } else {
      return {};
    }
  }

  @override
  Future<Map<String, String?>> readAll({String collectionName = ''}) async {
    final Map<String, String> result = await _storage.readAll();
    return result;
  }

  @override
  Future<void> update({
    String collectionName = '',
    required String key,
    required String value,
  }) async {
    assert(await _storage.containsKey(key: key), 'The key "$key" does not exists.');

    await _storage.write(key: key, value: value);
  }

  @override
  Future<void> updateMany({String collectionName = '', required Map<String, String> values}) async {
    for (String k in values.keys) {
      await update(key: k, value: values[k]!);
    }
  }

  @override
  Future<void> createOrUpdate({
    String collectionName = '',
    required String key,
    required String value,
  }) async {
    await _storage.write(key: key, value: value);
  }

  @override
  Future<void> createOrUpdateMany({
    String collectionName = '',
    required Map<String, String> values,
  }) async {
    for (String k in values.keys) {
      await createOrUpdate(key: k, value: values[k]!);
    }
  }

  @override
  Future<void> delete({String collectionName = '', required String key}) async {
    await _storage.delete(key: key);
  }

  @override
  Future<void> deleteMany({String collectionName = '', List<String> keys = const []}) async {
    if (keys.isNotEmpty) {
      for (String k in keys) {
        await _storage.delete(key: k);
      }
    }
  }

  @override
  Future<void> deleteAll({String collectionName = ''}) async {
    await _storage.deleteAll();
  }
}
```