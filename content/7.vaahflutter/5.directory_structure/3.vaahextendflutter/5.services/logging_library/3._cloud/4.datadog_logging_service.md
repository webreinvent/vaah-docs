---
toc: true
title: DataDog Logging Service
---



::alert{type="warning" class="p-4 mb-4 text-sm text-yellow-800 rounded-lg bg-yellow-50 dark:bg-gray-800 dark:text-yellow-300" role="alert"}
Dependencies

- [datadog_flutter_plugin](https://pub.dev/packages/datadog_flutter_plugin)
- [datadog_tracking_http_client](https://pub.dev/packages/datadog_tracking_http_client)

- implements LoggingService

::

::alert{type="danger" class="p-4 mb-4 text-sm text-blue-800 rounded-lg bg-blue-50 dark:bg-gray-800 dark:text-blue-400" role="alert"}
Developer Guide   

- Developer should never use this service directly, use [Logging Library](../logging_library.md) instead.

::




## DataDogLoggingService

- Implements [LoggingService](./logging_service.md).

- Provides methods which extends datadog services for Action, Error, Attribute and SetUserInfo.

## Configuration

- To configure datadog for your project you just have to pass `datadogConfig` in [environment config](../../../env.md).

  - You will have to add datadog `clientToken` and `applicationId` in `datadogConfig`.
  - Adding `site` to send information to. It determines the server for uploading RUM(Real User Monitoring) events

  - And you can configure SampleRate to trace uncaught errors. Value of `tracesSampleRate` (in `datadogConfig`) can be between 0 and 100. if value of `tracesSampleRate` is `20.0` then it will record 20% of uncaught errors, if it's `100.0` it will record 100% of uncaught errors.
  - You can configure `reportFlutterPerformance` and `nativeCrashReportEnabled` to trace performance of application and enable native crash reporting.
  - A list of `firstPartyHosts` and the types of tracing headers Datadog should automatically inject on resource calls. This is used in conjunction with Datadog network tracking packages like `datadog_tracking_http_client`

- Check [this](https://docs.datadoghq.com/real_user_monitoring/mobile_and_tv_monitoring/advanced_configuration/flutter/) datadog blog for, how to get config values.

## Source code
```dart
import 'dart:ui';
import 'package:datadog_flutter_plugin/datadog_flutter_plugin.dart';
import 'package:datadog_tracking_http_client/datadog_tracking_http_client.dart';
import 'package:flutter/material.dart';
import '../../../env/env.dart';
import '../_local/console_service.dart';
import '../models/log.dart';
import 'logging_service.dart';

class DataDogLoggingService implements LoggingService {
  static DatadogSdk? datadogSdk;

  static EnvironmentConfig get _config => EnvironmentConfig.getConfig;

  @override
  Future<Widget> init({
    required Widget app,
  }) async {
    // Initialize DataDog
    datadogSdk ??= DatadogSdk.instance;

    // Initialize the logger with network info enabled
    final configuration = DatadogLoggerConfiguration(networkInfoEnabled: true);
    datadogSdk?.logs?.createLogger(configuration);

    // Initialize DataDog with the configuration and consent
    datadogSdk?.initialize(await _generateConfig(), TrackingConsent.granted);

    // Initialize error handling
    _initializeErrorHandling();

    return app;
  }

// Generate config for DataDog
  static Future<DatadogConfiguration> _generateConfig() async {
    return DatadogConfiguration(
      clientToken: _config.datadogConfig?.clientToken ?? '',
      env: _config.envType.toLowerCase(),
      site: _config.datadogConfig?.site ?? DatadogSite.us5,
      nativeCrashReportEnabled: _config.datadogConfig?.nativeCrashReportEnabled ?? false,
      loggingConfiguration: DatadogLoggingConfiguration(),
      rumConfiguration: DatadogRumConfiguration(
        applicationId: _config.datadogConfig?.applicationId ?? '',
        sessionSamplingRate: 50,
        reportFlutterPerformance: _config.datadogConfig?.reportFlutterPerformance ?? false,
        traceSampleRate: _config.datadogConfig?.tracesSampleRate ?? 20.0,
      ),
      version: _config.version,
      firstPartyHosts: _config.datadogConfig?.firstPartyHosts ?? [],
    )..enableHttpTracking();
  }

// Initialize error handling
  static void _initializeErrorHandling() {
    final originalOnError = FlutterError.onError;
    FlutterError.onError = (details) {
      FlutterError.presentError(details);
      datadogSdk?.rum?.handleFlutterError(details);
      originalOnError?.call(details);
    };
    final platformOriginalOnError = PlatformDispatcher.instance.onError;
    PlatformDispatcher.instance.onError = (e, st) {
      datadogSdk?.rum?.addErrorInfo(
        e.toString(),
        RumErrorSource.source,
        stackTrace: st,
      );
      return platformOriginalOnError?.call(e, st) ?? false;
    };
  }

  @override
  Future<void> logException(throwable, {source, stackTrace, hint}) async {
    datadogSdk?.rum?.addError(
      throwable,
      source ?? RumErrorSource.custom,
      stackTrace: stackTrace,
      attributes: hint,
    );
  }

  @override
  Future<void> setUserInfoLogger({
    String? id,
    String? name,
    String? email,
    Map<String, dynamic>? extraInfo,
  }) async {
    datadogSdk?.setUserInfo(
      id: id,
      name: name,
      email: email,
      extraInfo: extraInfo ?? {},
    );
  }

  @override
  Future<void> logEvent({
    required String message,
    required EventType type,
    Object? data,
  }) async {
    Console.log(
      "~~~~~~> This method should be avoided with this logging service, as it doesn't do anything",
    );
  }

  @override
  Future<void> addEventsLogger({
    required RumActionType rumActionType,
    required String eventName,
    Map<String, Object>? eventProperties,
  }) async {
    datadogSdk?.rum?.addAction(
      rumActionType,
      eventName,
      eventProperties ?? {},
    );
  }

  @override
  Future<void> addSectionLogger({
    required String sectionName,
    required sectionValue,
  }) async {
    datadogSdk?.rum?.addAttribute(sectionName, sectionValue);
  }

  @override
  Future<void> logTransaction({
    required Function execute,
    required TransactionDetails details,
  }) async {
    Console.log(
      "~~~~~~> This method should be avoided with this logging service, as it doesn't do anything",
    );
  }
}



```
