---
toc: true
title: Platform Channel Service
description: Usage guide for the platform service in vaah flutter.
---

## Usage Guide

## Method Channels

The method channels are used to invoke methods defined in native side.


### Example

**Using the invokeMethod without arguments** 

The below code snippet is an example for retreiving the battery level which is first fetched in the kotlin(native side) then sent transmitted to the flutter side using the method channel.

**Dart Code**

```dart
String _batteryLevel = 'Unknown battery level.';
  Color backgroundColor = Colors.green.shade200;

  Future<void> _getBatteryLevel() async {
    String batteryLevel;
    try {
      final result = await PlatformService.invokeMethod<int>(
        'getBatteryLevel',
      );
      batteryLevel = 'Battery level at $result%.';
      if (result! < 5) {
        backgroundColor = Colors.red.shade200;
      } else if (result <= 20) {
        backgroundColor = Colors.orange.shade200;
      } else if (result <= 50) {
        backgroundColor = Colors.green.shade200;
      } else {
        backgroundColor = Colors.green.shade300;
      }
    } on PlatformException catch (e) {
      batteryLevel = "Failed to get battery level: '${e.message}'.";
    }

    setState(() {
      _batteryLevel = batteryLevel;
    });
  }
```

**Kotlin code**
```kotlin
private val CHANNEL = "com.example.app/method"
  override fun configureFlutterEngine(@NonNull flutterEngine: FlutterEngine) {
    super.configureFlutterEngine(flutterEngine)
    MethodChannel(flutterEngine.dartExecutor.binaryMessenger, CHANNEL).setMethodCallHandler {
      // This method is invoked on the main thread.
      call, result ->
      when (call.method) {
            "getBatteryLevel" -> {
                val batteryLevel = getBatteryLevel()

                if (batteryLevel != -1) {
                    result.success(batteryLevel)
                } else {
                    result.error("UNAVAILABLE", "Battery level not available.", null)
                }
            }
            else -> result.notImplemented()
        }
    }

  private fun getBatteryLevel(): Int {
    val batteryLevel: Int
    if (VERSION.SDK_INT >= VERSION_CODES.LOLLIPOP) {
      val batteryManager = getSystemService(Context.BATTERY_SERVICE) as BatteryManager
      batteryLevel = batteryManager.getIntProperty(BatteryManager.BATTERY_PROPERTY_CAPACITY)
    } else {
      val intent = ContextWrapper(applicationContext).registerReceiver(null, IntentFilter(Intent.ACTION_BATTERY_CHANGED))
      batteryLevel = intent!!.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) * 100 / intent.getIntExtra(BatteryManager.EXTRA_SCALE, -1)
    }
    return batteryLevel
  } 
```


## Source Code

### BasePlatformService class

```dart
abstract class BasePlatformService {
  Future<T?> invokeMethod<T>(String method, [dynamic arguments]);
  Stream<dynamic> getEventStream(String eventChannelName, [dynamic arguments]);
}
```

### PlatformChannelService Class 

```dart
import 'package:flutter/services.dart';

import '../../../env/env.dart';
import 'base_service.dart';

class PlatformChannelService implements BasePlatformService {
  final String _methodChannelName = EnvironmentConfig.getConfig.methodChannelName;
  static final Map<String, EventChannel> _eventChannels = {};

  @override
  Future<T?> invokeMethod<T>(String method, [dynamic arguments]) async {
    final MethodChannel channel = MethodChannel(_methodChannelName);
    try {
      final result = await channel.invokeMethod<T>(method, arguments);
      return result;
    } on MissingPluginException catch (e) {
      if (channel.name.isEmpty) {
        throw 'Please provide correct method_channel_name in env config: ${e.message}';
      }
      throw 'No plugin handler for the method call was found: ${e.message}(${channel.name})';
    } on PlatformException catch (e) {
      throw 'Failed to invoke method: ${e.message}';
    }
  }

  @override
  Stream<dynamic> getEventStream(String eventChannelName, [dynamic arguments]) {
    if (!_eventChannels.containsKey(eventChannelName)) {
      _eventChannels[eventChannelName] = EventChannel(eventChannelName);
    }
    return _eventChannels[eventChannelName]!.receiveBroadcastStream(arguments);
  }
}
```