---
title: Using k6
description: This document summarizes the main features and usage concepts of k6 to help you quickly understand how to write and run performance tests.
---

## Concepts Covered
1. **HTTP Requests** – Sending and configuring HTTP calls like GET and POST.
2. **Checks** – Validating response data using test assertions.
3. **Thresholds** – Setting pass/fail conditions based on performance metrics.
4. **Cookies** – Managing cookies for session handling and request continuity.

## HTTP Requests
When you create a new load test, one of the first steps is to define the HTTP requests that you would like to test.

### GET Request
A GET request looks like this
::code-group
    ```bash [get.js]
    import http from 'k6/http';

    export default function () {
    http.get('http://test.k6.io');
    }
::

### POST Request with JSON Payload
For something slightly more complex, this example shows a POST request with an email/password authentication payload:
::code-group
    ```bash [post.js]
    import http from 'k6/http';

    export default function () {
    const url = 'http://test.k6.io/login';
    const payload = JSON.stringify({
        email: 'aaa',
        password: 'bbb',
    });

    const params = {
        headers: {
        'Content-Type': 'application/json',
        },
    };

    http.post(url, payload, params);
    }
::

### Available HTTP Methods
k6's http module supports the following methods:
- `get()` — Perform a GET request
- `post()` — Perform a POST request
- `put()` — Perform a PUT request
- `del()` — Perform a DELETE request
- `head()` — Perform a HEAD request
- `options()` — Perform an OPTIONS request
- `patch()` — Perform a PATCH request
- `batch()` — Perform multiple HTTP requests in parallel
- `request()` — Perform any HTTP request with specified method

### HTTP Request Tags
k6 automatically applies tags to your HTTP requests, which can be used to filter and organize your test results. Default tags include:
- `expected_response` — Indicates if the response status is between 200 and 399.
- `group` — The group name if the request is part of a group.
- `name` — The name of the request, typically the URL.
- `method` — The HTTP method used (GET, POST, etc.).
- `scenario` — The scenario name if the request is part of a scenario.
- `status` — The response status code.
- `url` — The URL requested

You can customize these tags to group similar requests together. For example, to group requests to dynamic URLs under a single tag:
::code-group
    ```bash [script.js]
    import http from 'k6/http';

    export default function () {
    for (let id = 1; id <= 100; id++) {
        http.get(`http://example.com/posts/${id}`, {
        tags: { name: 'PostsItemURL' },
        });
    }
    }
::

For more detailed information and advanced usage, refer to the [HTTP Requests](https://grafana.com/docs/k6/latest/using-k6/http-requests/) documentation.


## Checks
In k6, checks are used to validate boolean conditions in your test scripts, similar to assertions in other testing frameworks. Unlike traditional assertions, failed checks do not halt the test execution; instead, they record the failure and allow the script to continue running.

### Check for HTTP response code
Checks are great for codifying assertions relating to HTTP requests and responses. For example, this snippet makes sure the HTTP response code is a 200:
::code-group
    ```bash [script.js]
    import { check } from 'k6';
    import http from 'k6/http';

    export default function () {
        const res = http.get('http://test.k6.io/');
        check(res, {
            'is status 200': (r) => r.status === 200,
        });
    }
::

### Check for text in response body
Sometimes, even an HTTP 200 response contains an error message. In these situations, consider adding a check to verify the response body, like this:
::code-group
    ```bash [script.js]
    import { check } from 'k6';
    import http from 'k6/http';

    export default function () {
        const res = http.get('http://test.k6.io/');
        check(res, {
            'verify homepage text': (r) =>
            r.body.includes('Collection of simple web-pages suitable for load testing'),
        });
    }
::

### See percentage of checks that passed
When a script includes checks, the summary report shows how many of the tests’ checks passed:
<img src="/images/testing/k6_single_check_output.png">

### Add multiple checks
You can also add multiple checks within a single check() statement:
::code-group
    ```bash [script.js]
    import { check } from 'k6';
    import http from 'k6/http';

    export default function () {
        const res = http.get('http://test.k6.io/');
        check(res, {
            'is status 200': (r) => r.status === 200,
            'body size is 11,105 bytes': (r) => r.body.length == 11105,
        });
    }
::
<img src="/images/testing/k6_multi_check_output.png">

## Thresholds
Thresholds are the pass/fail criteria that you define for your test metrics. If the performance of the system under test (SUT) does not meet the conditions of your threshold, the test finishes with a failed status.

Often, testers use thresholds to codify their SLOs. For example, you can create thresholds for any combination of the following expectations:

- Less than 1% of requests return an error.
- 95% of requests have a response time below 200ms.
- 99% of requests have a response time below 400ms.
- A specific endpoint always responds within 300ms.

### How to Define Thresholds
Thresholds are set inside the options object in your k6 script. You specify which metric to monitor and the condition it must meet.
```js
export const options = {
  thresholds: {
    'http_req_duration': ['p(95)<5000'],  // 95% of requests must finish in under 5000 ms
    'http_req_failed': ['rate<0.01'],     // Less than 1% of requests should fail
  },
};
```
- Here, http_req_duration measures how long requests take.
- p(95)<5000 means the 95th percentile of request durations must be less than 5000 milliseconds.
- http_req_failed tracks failed requests.
- rate<0.01 means the failure rate must be under 1%.

If either rule is broken, the test will fail.

### Supported Metrics and Aggregation Types
You can apply thresholds to many built-in metrics such as:
- http_req_duration (request duration)
- http_req_failed (error rate)
- checks (success rate of checks/assertions)
- vus (number of virtual users)
- iterations (number of completed iterations)

Threshold aggregations you can use include:
- avg (average)
- min (minimum)
- max (maximum)
- med (median)
- p(N) (percentile, e.g., p(90) for 90th percentile)

Using percentiles (p(N)) is preferred because minimum and maximum values can be outliers.

### Using Multiple Thresholds on One Metric
You can add multiple thresholds for the same metric by listing them in an array. This helps you monitor performance at several levels.

```js
export const options = {
  thresholds: {
    'http_req_duration': [
      'p(90)<400',    // 90% of requests < 400 ms
      'p(95)<800',    // 95% of requests < 800 ms
      'p(99.9)<2000', // 99.9% of requests < 2000 ms
    ],
  },
};
```

### Fail a load test using checks
Checks are nice for codifying assertions, but unlike thresholds, checks do not affect the exit status of k6.

If you use only checks to verify that things work as expected, you can’t fail the whole test run based on the check results.

It’s often useful to combine checks and thresholds, to get the best of both:
::code-group
    ```bash[script.js]
    import http from 'k6/http';
    import { check, sleep } from 'k6';

    export const options = {
        vus: 50,
        duration: '10s',
        thresholds: {
            // the rate of successful checks should be higher than 90%
            checks: ['rate>0.9'],
        },
    };

    export default function () {
        const res = http.get('https://quickpizza.grafana.com/api/status/500');

        check(res, {
            'status is 500': (r) => r.status == 500,
        });

        sleep(1);
    }
::
In this example, the threshold is configured on the checks metric, establishing that the rate of successful checks is higher than 90%.

To know more about the threshold, kindly refer to the official [documentation](https://grafana.com/docs/k6/latest/using-k6/thresholds/) for k6 thresholds.

## Cookies
HTTP Cookies are used by websites and apps to store pieces of stateful information on user devices. Through the Set-Cookie HTTP header, a server tells a client what information it wants stored on the user machine.

To simulate that a cookie has previously been set by a browser and is now supposed to be included in subsequent requests to the server, include the cookie in the cookies request parameter:

::code-group
    ```bash[script.js]
    import http from 'k6/http';

    export default function () {
        http.get('https://quickpizza.grafana.com/api/cookies', {
            cookies: {
                my_cookie: 'hello world',
            },
        });
    }
::

To see which cookies were set for a particular response, look in the cookies property of the response object:
::code-groups
    ```bash[script.js]
    import http from 'k6/http';
    import { check } from 'k6';

    export default function () {
        const res = http.post('https://quickpizza.grafana.com/api/cookies?my_cookie=hello%20world', {
            redirects: 0,
        });
        check(res, {
            "has cookie 'my_cookie'": (r) => r.cookies.my_cookie.length > 0,
            'cookie has correct value': (r) => r.cookies.my_cookie[0].value === 'hello world',
        });
    }
::
The response object’s cookies property is a map where the key is the cookie name and the value is an array of response cookie objects. 

To know more about the cookies, kindly refer to the official [documentation](https://grafana.com/docs/k6/latest/using-k6/cookies/) for k6 cookies.